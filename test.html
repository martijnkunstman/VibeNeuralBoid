<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>2D Vehicle Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
            background: #222;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <script>
        // --- Vector Utility ---
        class Vector {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }
            copy() { return new Vector(this.x, this.y); }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            mult(n) { this.x *= n; this.y *= n; return this; }
            div(n) { this.x /= n; this.y /= n; return this; }
            mag() { return Math.hypot(this.x, this.y); }
            normalize() { let m = this.mag() || 1; return this.div(m); }
            static fromAngle(a) { return new Vector(Math.cos(a), Math.sin(a)); }
        }

        // --- Vehicle Class (Kinematic Bicycle Model) ---
        class Vehicle {
            constructor(x, y) {
                this.position = new Vector(x, y);
                this.orientation = 0;      // radians
                this.speed = 0;            // px/sec
                this.wheelBase = 40;       // distance between axles
                this.maxSteer = Math.PI / 4; // max wheel angle
                this.engineForce = 300;    // accel force
                this.brakeForce = 400;     // braking force
                this.drag = 0.02;          // linear drag
                this.steer = 0;            // current steering angle
                this.steerDirection = 0; // -1 for left, 1 for right
            }

            update(dt, keys) {
                // acceleration
                if (keys['w']) {
                    this.speed += (this.engineForce * dt);
                }
                // braking
                if (keys['s']) {
                    this.speed -= (this.brakeForce * dt);
                }
                // drag
                this.speed -= this.speed * this.drag;
                // clamp
                this.speed = Math.max(0, Math.min(this.speed, 500));

                // steering
                if (keys['a']) this.steerDirection = this.steerDirection - this.maxSteer / 10;
                if (keys['d']) this.steerDirection = this.steerDirection + this.maxSteer / 10;

                if (this.steerDirection > this.maxSteer) this.steerDirection = this.maxSteer;
                if (this.steerDirection < -this.maxSteer) this.steerDirection = -this.maxSteer;

                if (keys['a'] && keys['d']) {
                    this.steerDirection *= 0.8; // damp steering input
                }

                this.steer = this.steer + this.steerDirection;

                if (this.steer > this.maxSteer) this.steer = this.maxSteer;
                if (this.steer < -this.maxSteer) this.steer = -this.maxSteer;

                this.steer *= 0.8; // damp steering if no input

                if (!keys['a'] && !keys['d']) {
                    this.steerDirection = 0;
                }

                if (this.speed > 0) {
                    const turnRate = (this.speed / this.wheelBase) * Math.tan(this.steer);
                    this.orientation += turnRate * dt;
                }

                // move
                const vel = Vector.fromAngle(this.orientation).mult(this.speed * dt);
                this.position.add(vel);
            }

            draw(ctx) {
                // draw vehicle body
                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(this.orientation);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(-20, -10, 40, 20);
                // wheels
                ctx.fillStyle = '#555';
                ctx.fillRect(-15, -12, 8, 4);
                ctx.fillRect(-15, 8, 8, 4);
                ctx.fillRect(7, -12, 8, 4);
                ctx.fillRect(7, 8, 8, 4);
                ctx.restore();
            }
        }

        // --- Setup ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // input
        const keys = {};
        window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

        // world & vehicle
        const veh = new Vehicle(width / 2, height / 2);

        // wrap-around
        function wrap(v) {
            if (v.position.x < 0) v.position.x += width;
            if (v.position.x > width) v.position.x -= width;
            if (v.position.y < 0) v.position.y += height;
            if (v.position.y > height) v.position.y -= height;
        }

        // main loop
        let lastTime = performance.now();
        function loop(time) {
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            veh.update(dt, keys);
            wrap(veh);

            ctx.clearRect(0, 0, width, height);
            veh.draw(ctx);

            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
    </script>
</body>

</html>